# Test Docstring Template

Use this template as a guide when writing or updating test docstrings.

## Standard Format

```python
def test_feature_behavior_expected_outcome(self):
    """Brief one-line summary of what this test verifies (imperative mood).

    **Invariant:** [invariant-category-number] (if applicable)

    Extended description providing context about:
    - What behavior/property is being tested
    - Why this test is important
    - Edge cases or special conditions covered

    **Setup:**
    - Key parameters: profit_aim=X, risk_reward_ratio=Y
    - Test scenarios: duration_ratios=[...], modes=[...]
    - Sample size: N samples

    **Assertions:**
    - Primary check: What the main assertion verifies
    - Secondary checks: Additional validations (if any)

    **Tolerance rationale:** (if using custom tolerance)
    - [TOLERANCE.TYPE]: Reason for this tolerance choice
      Example: IDENTITY_RELAXED for accumulated errors across 5+ operations

    **See also:**
    - Related tests: test_other_related_feature
    - Documentation: Section 3.2 in PBRS guide
    """
    # Test implementation
    pass
```

## Quick Examples

### Minimal (Simple Test)

```python
def test_transform_zero_input(self):
    """All potential transforms should map zero to zero."""
    for transform in TRANSFORM_MODES:
        result = apply_transform(0.0, transform)
        self.assertAlmostEqual(result, 0.0, places=12)
```

### Standard (Most Tests)

```python
def test_exit_factor_monotonic_attenuation(self):
    """Exit factor must decrease monotonically with increasing duration ratio.

    **Invariant:** robustness-exit-monotonic-115

    Validates that for all attenuation modes (linear, sqrt, power, etc.),
    the exit factor decreases as duration_ratio increases, ensuring
    that longer-held positions receive progressively smaller rewards.

    **Setup:**
    - Attenuation modes: [linear, sqrt, power, half_life]
    - Duration ratios: [0.0, 0.5, 1.0, 1.5, 2.0]
    - PnL: 0.05, target: 0.10

    **Assertions:**
    - Strict monotonicity: factor[i] > factor[i+1] for all i
    - Lower bound: All factors remain non-negative

    **Tolerance rationale:**
    - IDENTITY_RELAXED: Exit factor computation involves normalization,
      kernel application, and optional transforms (3-5 operations)
    """
    # Test implementation
    pass
```

### Complex (Multi-Part Test)

```python
def test_pbrs_terminal_state_comprehensive(self):
    """PBRS terminal potential must be zero and shaping must recover last potential.

    **Invariant:** pbrs-terminal-zero-201, pbrs-recovery-202

    Comprehensive validation of PBRS terminal state behavior across all
    exit potential modes (progressive_release, spike_cancel, canonical).
    Ensures theoretical PBRS guarantees hold in practice.

    **Background:**
    PBRS theory (Ng et al., 1999) requires terminal potential = 0 to
    maintain policy invariance. This test verifies implementation correctness.

    **Test structure:**
    1. Part A: Terminal potential verification
       - For each exit mode, compute next_potential at terminal state
       - Assert: next_potential ≈ 0 within TOLERANCE.IDENTITY_RELAXED

    2. Part B: Shaping recovery verification
       - Verify: reward_shaping ≈ -prev_potential (canonical exit)
       - Checks proper potential release at terminal

    3. Part C: Cumulative shaping magnitude
       - Track cumulative shaping over 100-episode sequence
       - Assert: Bounded magnitude (no systematic bias accumulation)

    **Setup:**
    - Exit modes: [progressive_release, spike_cancel, canonical]
    - Gamma values: [0.9, 0.95, 0.99]
    - Episodes: 100 per configuration
    - Sample size: 500 steps per episode

    **Assertions:**
    - Terminal potential: |next_potential| < TOLERANCE.IDENTITY_RELAXED
    - Shaping recovery: |shaping + prev_potential| < TOLERANCE.IDENTITY_RELAXED
    - Cumulative sum bound: |sum(shaping)| < 10 * TOLERANCE.IDENTITY_RELAXED

    **Tolerance rationale:**
    - IDENTITY_RELAXED: PBRS calculations involve gamma discounting,
      potential computations (hold/entry/exit), and reward shaping formula.
      Each operation accumulates ~1e-16 error; 5-10 operations → 1e-09 bound.

    **See also:**
    - test_pbrs_spike_cancel_invariance: Focused spike_cancel test
    - test_pbrs_progressive_release_decay: Decay mechanism validation
    - docs/PBRS_THEORY.md: Mathematical foundations
    """
    # Part A implementation
    for mode in EXIT_MODES:
        # ...

    # Part B implementation
    # ...

    # Part C implementation
    # ...
```

## Section Guidelines

### **One-Line Summary**

- Use imperative mood: "Verify X does Y", "Check that A equals B"
- Be specific: "Exit factor decreases monotonically" not "Test exit factor"
- Focus on **what** is tested, not **how** it's tested

### **Invariant** (if applicable)

- Format: `**Invariant:** category-name-number`
- Example: `**Invariant:** pbrs-terminal-zero-201`
- See `tests/helpers/assertions.py` for invariant documentation

### **Extended Description**

- Explain **why** this test exists
- Provide context about the feature being tested
- Mention edge cases or special conditions

### **Setup**

- Key parameters and their values
- Test scenarios (modes, ratios, sample sizes)
- Any special configuration

### **Assertions**

- What each major assertion validates
- Expected relationships or properties
- Bounds and thresholds

### **Tolerance Rationale**

- **Required** if using non-default tolerance
- Explain accumulated error sources
- Justify the specific tolerance magnitude
- See `constants.py` docstrings for available tolerances

### **See Also**

- Related tests
- Relevant documentation
- Theory references

## Common Patterns

### Property-Based Test

```python
def test_property_holds_for_all_inputs(self):
    """Property X holds for all valid inputs in domain D.

    Property-based test verifying [property] across [input space].
    Uses parameterized inputs to ensure comprehensive coverage.
    """
```

### Regression Test

```python
def test_issue_123_regression_is_prevented(self):
    """Regression test for Issue #123: [brief description].

    Validates behavior for [conditions] and asserts the expected outcome.

    **Tracking:** Issue #123
    """
```

### Integration Test

```python
def test_end_to_end_workflow_integration(self):
    """End-to-end integration test for [workflow].

    Validates complete workflow from [start] to [end], including:
    - Component A: [responsibility]
    - Component B: [responsibility]
    - Component C: [responsibility]

    **Integration points:**
    - A → B: [interface/data flow]
    - B → C: [interface/data flow]
    """
```

## Anti-Patterns to Avoid

### ❌ Vague One-Liners

```python
def test_reward_calculation(self):
    """Test reward calculation."""  # Too vague!
```

### ❌ Implementation Details

```python
def test_uses_numpy_vectorization(self):
    """Test uses numpy for speed."""  # Focus on behavior, not implementation
```

### ❌ Missing Tolerance Justification

```python
def test_complex_calculation(self):
    """Test complex multi-step calculation."""
    result = complex_function(...)
    self.assertAlmostEqual(result, expected, delta=TOLERANCE.IDENTITY_RELAXED)
    # ❌ Why IDENTITY_RELAXED? Should explain!
```

### ❌ Overly Technical Jargon

```python
def test_l2_norm_convergence(self):
    """Test that the L2 norm of the gradient converges under SGD."""
    # ❌ Unless testing ML internals, use domain language
```

## Checklist for New Tests

- [ ] One-line summary is clear and specific
- [ ] Invariant listed (if applicable)
- [ ] Extended description explains why test exists
- [ ] Setup section documents key parameters
- [ ] Assertions section explains what's validated
- [ ] Tolerance rationale provided (if custom tolerance used)
- [ ] References to related tests/docs (if applicable)
- [ ] Test name follows convention: `test_category_behavior_outcome`
- [ ] Docstring uses proper markdown formatting
- [ ] No implementation details leaked into description

## References

- **Test Naming:** Follow pytest conventions and project standards
- **Invariant Documentation:** See `tests/helpers/assertions.py`
- **Tolerance Selection:** See `tests/constants.py` for available tolerances
- **Test Organization:** See `tests/README.md`

---

**Note:** Not all sections are required for every test. Simple tests can use minimal format.
Complex tests should use comprehensive format with all relevant sections.
